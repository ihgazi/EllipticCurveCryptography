"""
"" 20th OCT 2025 ::: Irfan Habeeb Gazi
"" 29th OCT 2025 ::: Surjayan Kar
"" 1st NOV 2025 ::: Vivek Halder
""
"" Usage: sage Decrypt.py <priv_key> <pub_key> <ciphertext>
""
"" This program decrypts a given ciphertext (stored as a pair of points) using Elliptic Curve Cryptography.
"" The private and public key files must generated by the user and stored in the corresponding files. 
"" Please refer to KeyGeneration.py and KeyGenerationUtil.py for more details.
"" The ciphertext is expected to encrypted by the sender using Encrypt.py. Please refer to the program for more details.
"" The decyprted message is printed to the console.
""
"" The arguments to be provided to the program are as follows:
"" 1. <priv_key> : The path to file containing the private key.
"" 2. <public_key> : The path to file containing the public key for the cryptosystem. This file also 
"" stores the elliptic curve parameters to be used.
"" 3. <ciphertext> : The ciphertext (pair of points) to be decrypted. This file must be generated by the sender
"" using Encrypt.py on a valid message.
""
"" <Sample Input / Output>
""
"" INPUT 1:
"" ecc_public_key.txt:-
"" {
"" public_key": "(7 : 13*a + 1 : 1)",
"" generator": "(8 : 16*a + 7 : 1)",
"" coefficients": "(2, 3, 5, 7, 11)",
"" field_order": "289",
"" field_degree": "2"
"" }
""
"" ecc_private_key.txt:-
"" {
"" private_key": "13"
"" }
""
"" ecc_ciphertext.txt:-
"" {
"" C1": "(14 : 11*a + 12 : 1)",
"" C2": "(14*a + 13 : 16*a + 12 : 1)"
"" }
""
"" OUTPUT 1:
"" Decrypted Message Point M: (12 : 2 : 1)
"""

import sys
import json
from sage.all import *

USAGE = "sage Decrypt.py <priv_key> <pub_key> <ciphertext>"
if (len(sys.argv) != 4):
    print("Invalid Arguments!")
    print(f"\nUsage: {USAGE}")
    exit(1)


def load_json(filename):
    with open(filename, 'r') as file:
        data = json.load(file)
    return data


def parse_field(base_field, field_degree):
    if field_degree == 1:
        return GF(field_order)
    else:
        return GF((base_field, field_degree), names=('a',))


def parse_coeffs(coeffs_str, K):
    return [K(c.strip()) for c in coeffs_str]


def parse_point(point_str, E):
    point_str = point_str.strip()
    point_str = point_str[1:-1]
    coords = [s.strip() for s in point_str.split(':')]

    if len(coords) != 3:
        raise ValueError("Invalid point format: " + point_str)

    try:
        x = E.base_field()(coords[0])
        y = E.base_field()(coords[1])
        z = E.base_field()(coords[2])
    except Exception as ex:
        raise ValueError(
            f"Invalid coordinate in point: {point_str}. Error: {ex}")

    try:
        point = E(x, y, z)
    except Exception as ex:
        raise ValueError(
            f"Failed to construct point on curve: {point_str}. Error: {ex}"
        )

    return point


def parse_private_key(priv_key_str):
    return Integer(priv_key_str.strip())


def parse_ciphertext(ciphertext, E):
    C1_str, C2_str = ciphertext['C1'], ciphertext['C2']
    C1 = parse_point(C1_str, E)
    C2 = parse_point(C2_str, E)
    return C1, C2


def main():
    priv = load_json(sys.argv[1])
    pub = load_json(sys.argv[2])
    ciphertext = load_json(sys.argv[3])

    base_field = int(pub['base_field'].strip())
    field_degree = int(pub['field_degree'].strip())
    coeffs_str = pub['coefficients']
    coeffs_str = coeffs_str[1:-1].split(',')
    generator_str = pub['generator']
    public_key_str = pub['public_key']

    K = parse_field(base_field, field_degree)
    coeffs = parse_coeffs(coeffs_str, K)
    E = EllipticCurve(K, coeffs)
    G = parse_point(generator_str, E)
    public_key = parse_point(public_key_str, E)

    private_key = parse_private_key(priv['private_key'])

    C1, C2 = parse_ciphertext(ciphertext, E)

    M = C2 - private_key * C1

    print("Decrypted Message Point M: " + str(M))


if __name__ == "__main__":
    main()
